<!--
  Documentation for "Teem: Gordon Kindlmann's research software"
  Copyright (C)  2005 Gordon Kindlmann
  Copyright (C)  2004, 2003, 2002, 2001, 2000 University of Utah
  This documentation may not be modified or redistributed in any
  form, except by the copyright holder.
-->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
   "http://www.w3.org/TR/html/4/loose.dtd"> 
<html>
<head>
<title>
Teem: Nrrd: Library Description
</title>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII"> 
</head>
<body bgcolor="#ffffff">
<a href="http://sourceforge.net/projects/teem"><img 
 src="http://sflogo.sourceforge.net/sflogo.php?group_id=85445&amp;type=13"
 align=right width="120" height="30" alt="Get Teem at SourceForge.net. Fast, secure and Free Open Source software downloads" /></a>
<table border=0 cellpadding=0 cellspacing=0>
<tr>
  <td width=80 height=80>
    <a href="../index.html"><img border=0 width=80 height=80 alt=""
    src="../img/teem80.jpg"></a>
  <td height=80>
  <td width=80 height=80>
    <a href="./index.html"><img border=0 width=80 height=80 alt=""
    src="../img/nrrd80.jpg"></a>
  <td>
<tr>
  <td width=80 align=center valign=top>
    <b><a href="../index.html">Teem</a></b>
  <td valign=top>
    <b>/</b>
  <td width=80 align=center valign=top>
    <b><a href="./index.html">Nrrd</a></b>
  <td>
    <h2>&nbsp;&nbsp;Library Description</h2>
</table>

<table border=1>
<tr><td>
<ol>
<li><a href="#structs">Data Structures</a>
<li><a href="#io">Input/Output functions, with error reporting</a>
<li><a href="#alloc">Reading a NRRD with a different memory allocator</a>
<li><a href="#data">Getting data into and out of nrrds</a>
<li><a href="#peraxis">Setting/Getting per-axis information</a>
<li><a href="#keyvalue">Key/Value Pairs</a>
<li><a href="#space">Space and Orientation</a>
<li><a href="#overview">Overview of rest of API</a>
</ol>
</table>

<p>

This page is intended to be a basic introduction to programming with
the <b>Nrrd</b> API.  The stand-alone <b>NrrdIO</b> library includes
all the functions described in Section 1 through 7; it lacks the
functions (listed in Section 8) which perform non-trivial
manipulations of the array values.  This page will make the most sense
if you already know what sort of data and meta-data can be represented
in a nrrd.  The <a href="intro.html">Introduction</a> to Nrrd is
useful in this respect, as is the <a href="descformat.html">General
Description of the NRRD Format</a>. The <a
href="format.html">Definition of NRRD File Format</a> is a 
detailed and "bottom-up" view of what can go into a nrrd, from the
standpoint of the written file.  This will do the same thing, from the
standpoint of what is available as data structures in memory.

<a name="structs"><h2>1. Data Structures</h2></a>

We start with the <tt>Nrrd</tt> data structure.  This comes in two
parts: the struct for per-axis information (<tt>NrrdAxis</tt>), and the main 
<tt>Nrrd</tt> struct which includes an array of <tt>NrrdAxis</tt>s.  These
are extracted from <tt>teem/src/nrrd/nrrd.h</tt>
(or <tt>NrrdIO.h</tt>).

<blockquote><pre>
/*
******** NrrdAxisInfo struct
**
** all the information which can sensibly be associated with
** one axis of a nrrd.  The only member which MUST be explicitly
** set to something meaningful is "size".
**
** If an axis lies conceptually along some direction in an enclosing
** space of dimension nrrd-&gt;spaceDim, then the first nrrd-&gt;spaceDim
** entries of spaceDirection[] must be non-NaN, and min, max, spacing,
** and units must NOT be set;  thickness, center, and label can still
** be used.  The mutual exclusion between axis-aligned and general
** direction information is enforced per-axis, not per-array.
**
** The min and max values give the range of positions "represented"
** by the samples along this axis.  In node-centering, "min" IS the
** position at the lowest index.  In cell-centering, the position at
** the lowest index is between min and max (a touch bigger than min,
** assuming min &lt; max).
**
** There needs to be a one-to-one correspondence between these variables
** and the nrrdAxisInfo* enum (nrrdEnums.h), the per-axis header fields
** (see nrrdField* enum in nrrdEnums.h), and the various methods in axis.c
*/
typedef struct {
  size_t size;              /* number of elements along each axis */
  double spacing;           /* if non-NaN, distance between samples */
  double thickness;         /* if non-NaN, nominal thickness of region
                               represented by one sample along the axis. No
                               semantics relative to spacing are assumed or
                               imposed, and unlike spacing, there is no
                               sensible way to alter thickness- it is either
                               copied (as with cropping and slicing) or set to
                               NaN (when resampled). */
  double min, max;          /* if non-NaN, range of positions spanned by the
                               samples on this axis.  Obviously, one can set
                               "spacing" to something incompatible with min
                               and max: the idea is that only one (min and
                               max, or spacing) should be taken to be
                               significant at any time. */
  double spaceDirection[NRRD_SPACE_DIM_MAX]; 
                            /* the vector, in "space" (as described by
                               nrrd-&gt;space and/or nrrd-&gt;spaceDim), from one
                               sample to the next sample along this axis.  It
                               is the column vector of the transform from
                               index space to "space" space */
  int center;               /* cell vs. node centering (value should be one of
                               nrrdCenter{Unknown,Node,Cell} */
  int kind;                 /* what kind of information is along this axis
                               (from the nrrdKind* enum) */
  char *label,              /* short info string for each axis */
    *units;                 /* string identifying the unit */
} NrrdAxisInfo;

/*
******** Nrrd struct
**
** The struct used to wrap around the raw data array
*/
typedef struct {
  /* 
  ** NECESSARY information describing the main array.  This is
  ** generally set at the same time that either the nrrd is created,
  ** or at the time that the nrrd is wrapped around an existing array 
  */

  void *data;                       /* the data in memory */
  int type;                         /* a value from the nrrdType enum */
  unsigned int dim;                 /* the dimension (rank) of the array */

  /* 
  ** All per-axis specific information
  */
  NrrdAxisInfo axis[NRRD_DIM_MAX];  /* axis[0] is the fastest axis in the scan-
                                       line ordering, the one who's coordinates
                                       change the fastest as the elements are
                                       accessed in the order in which they
                                       appear in memory */

  /* 
  ** Optional information descriptive of whole array, some of which is
  ** meaningfuly for only some uses of a nrrd
  */
  char *content;                    /* brief account of what this data is */
  char *sampleUnits;                /* units of measurement of the values 
                                       stored in the array itself (not the 
                                       array axes and not space coordinates).
                                       The logical name might be "dataUnits",
                                       but that's perhaps ambiguous.  Note that
                                       these units may apply to non-scalar
                                       kinds (e.g. coefficients of a vector
                                       have the same units) */
  int space;                        /* from nrrdSpace* enum, and often 
                                       implies the value of spaceDim */
  unsigned int spaceDim;            /* if non-zero, the dimension of the space
                                       in which the regular sampling grid
                                       conceptually lies.  This is a separate
                                       variable because this dimension can be
                                       different than the array dimension. 
                                       The non-zero-ness of this value is in 
                                       fact the primary indicator that space
                                       and orientation information is set.
                                       This identifies the number of entries in
                                       "origin" and the per-axis "direction"
                                       vectors that are taken as meaningful */
  char *spaceUnits[NRRD_SPACE_DIM_MAX];
                                    /* units for coordinates of space */
  double spaceOrigin[NRRD_SPACE_DIM_MAX];
                                    /* the location of the center the first
                                       (lowest memory address) array sample,
                                       regardless of node-vs-cell centering */
  double measurementFrame[NRRD_SPACE_DIM_MAX][NRRD_SPACE_DIM_MAX];
                                    /* if spaceDim is non-zero, this may store 
                                       a spaceDim-by-spaceDim matrix which 
                                       transforms vector/matrix coefficients
                                       in the "measurement frame" to those in
                                       the world space described by spaceDim
                                       (and hopefully space).  Coeff [i][j] is
                                       *column* i & *row* j, which is probably
                                       the *transpose* of what you expect.
                                       There are no semantics linking this to
                                       the "kind" of any axis, for a variety
                                       of reasons */
  size_t blockSize;                 /* for nrrdTypeBlock, block byte size */
  double oldMin, oldMax;            /* if non-NaN, and if nrrd is of integral
                                       type, extremal values for the array
                                       BEFORE it was quantized */
  void *ptr;                        /* never read or set by nrrd; use/abuse
                                       as you see fit */

  /* 
  ** Comments.  Read from, and written to, header.
  ** The comment array "cmt" is NOT NULL-terminated.
  ** The number of comments is cmtArr-&gt;len.
  */
  char **cmt;
  airArray *cmtArr;

  /*
  ** Key-value pairs.
  */
  char **kvp;
  airArray *kvpArr;
} Nrrd;
</pre></blockquote>

<p>

<b>Nrrd</b> uses C enums for representing discrete information with more
semantic content than a normal integer.  The three most important are:
<ul>
<li> <tt>nrrd-&gt;type</tt> takes on values from the <tt>nrrdType</tt> enum:
<pre>
/*
******** nrrdType enum
**
** all the different types, identified by integer
*/
enum {
  nrrdTypeUnknown=0,     /*  0: signifies "type is unset/unknown" */
  nrrdTypeDefault=0,     /*  0: signifies "determine output type for me" */
  nrrdTypeChar,          /*  1:   signed 1-byte integer */
  nrrdTypeUChar,         /*  2: unsigned 1-byte integer */
  nrrdTypeShort,         /*  3:   signed 2-byte integer */
  nrrdTypeUShort,        /*  4: unsigned 2-byte integer */
  nrrdTypeInt,           /*  5:   signed 4-byte integer */
  nrrdTypeUInt,          /*  6: unsigned 4-byte integer */
  nrrdTypeLLong,         /*  7:   signed 8-byte integer */
  nrrdTypeULLong,        /*  8: unsigned 8-byte integer */
  nrrdTypeFloat,         /*  9:          4-byte floating point */
  nrrdTypeDouble,        /* 10:          8-byte floating point */
  nrrdTypeBlock,         /* 11: size user defined at run time; MUST BE LAST */
  nrrdTypeLast
};
</pre>
<li> <tt>nrrd-&gt;axis[i].center</tt> takes on values from the <tt>nrrdCenter</tt> enum:
<pre>
/*
******** nrrdCenter enum
**
** node-centered vs. cell-centered
*/
enum {
  nrrdCenterUnknown,         /* 0: no centering known for this axis */
  nrrdCenterNode,            /* 1: samples at corners of things
                                (how "voxels" are usually imagined)
                                |\______/|\______/|\______/|
                                X        X        X        X   */
  nrrdCenterCell,            /* 2: samples at middles of things
                                (characteristic of histogram bins)
                                 \___|___/\___|___/\___|___/
                                     X        X        X       */
  nrrdCenterLast
};
</pre>
<li> <tt>nrrd-&gt;axis[i].kind</tt> takes on values from the <tt>nrrdKind</tt> enum:
<pre>
/*
******** nrrdKind enum
**
** For describing the information along one axis of an array.  This is
** most important for clarifying the representation of non-scalar
** data, in order to distinguish between axes that are genuine image
** domain axes, and axes that exist just to store the multiple
** attributes per sample.  One could argue that this information
** should be per-array and not per-axis, but you still have to
** indicate which one of the axes is the attribute axis.  And, if you
** have, say, the gradient of RGB colors, you want the per-pixel 3x3
** array to have those two attribute axes tagged accordingly.
**
** More of these may be added in the future, such as when nrrd
** supports bricking.  Since nrrd is never going to be in the business
** of manipulating the kind information or supporting kind-specific
** semantics, there can be proliferation of nrrdKinds, provided
** pointless redundancy is avoided.  
**
**  There is a relationship between some of these (nrrdKindSpace is a
** specific nrrdKindDomain), but currently there is no effort to
** record this meta-kind information.
**
** Keep in sync:
**   enumsNrrd.c: nrrdKind airEnum
**        axis.c: nrrdKindSize()
**        axis.c: _nrrdKindAltered()
**
** NOTE: The nrrdKindSize() function returns the valid size for these.
** 
*/
enum {
  nrrdKindUnknown,
  nrrdKindDomain,            /*  1: any image domain */
  nrrdKindSpace,             /*  2: a spatial domain */
  nrrdKindTime,              /*  3: a temporal domain */
  /* -------------------------- end domain kinds */
  /* -------------------------- begin range kinds */
  nrrdKindList,              /*  4: any list of values, non-resample-able */
  nrrdKindPoint,             /*  5: coords of a point */
  nrrdKindVector,            /*  6: coeffs of (contravariant) vector */
  nrrdKindCovariantVector,   /*  7: coeffs of covariant vector (eg gradient) */
  nrrdKindNormal,            /*  8: coeffs of unit-length covariant vector */
  /* -------------------------- end arbitrary size kinds */
  /* -------------------------- begin size-specific kinds */
  nrrdKindStub,              /*  9: axis with one sample (a placeholder) */
  nrrdKindScalar,            /* 10: effectively, same as a stub */
  nrrdKindComplex,           /* 11: real and imaginary components */
  nrrdKind2Vector,           /* 12: 2 component vector */
  nrrdKind3Color,            /* 13: ANY 3-component color value */
  nrrdKindRGBColor,          /* 14: RGB, no colorimetry */
  nrrdKindHSVColor,          /* 15: HSV, no colorimetry */
  nrrdKindXYZColor,          /* 16: perceptual primary colors */
  nrrdKind4Color,            /* 17: ANY 4-component color value */
  nrrdKindRGBAColor,         /* 18: RGBA, no colorimetry */
  nrrdKind3Vector,           /* 19: 3-component vector */
  nrrdKind3Gradient,         /* 20: 3-component covariant vector */
  nrrdKind3Normal,           /* 21: 3-component covector, assumed normalized */
  nrrdKind4Vector,           /* 22: 4-component vector */
  nrrdKindQuaternion,        /* 23: (x,y,z,w), not necessarily normalized */
  nrrdKind2DSymMatrix,       /* 24: Mxx Mxy Myy */
  nrrdKind2DMaskedSymMatrix, /* 25: mask Mxx Mxy Myy */
  nrrdKind2DMatrix,          /* 26: Mxx Mxy Myx Myy */
  nrrdKind2DMaskedMatrix,    /* 27: mask Mxx Mxy Myx Myy */
  nrrdKind3DSymMatrix,       /* 28: Mxx Mxy Mxz Myy Myz Mzz */
  nrrdKind3DMaskedSymMatrix, /* 29: mask Mxx Mxy Mxz Myy Myz Mzz */
  nrrdKind3DMatrix,          /* 30: Mxx Mxy Mxz Myx Myy Myz Mzx Mzy Mzz */
  nrrdKind3DMaskedMatrix,    /* 31: mask Mxx Mxy Mxz Myx Myy Myz Mzx Mzy Mzz */
  nrrdKindLast
};
</pre>
</ul>

In general, you do not directly set the struct members- you set this
information via functions in the <b>Nrrd</b> API.  As a matter of
convenience, however, it is common and okay to read value directly
from the <tt>Nrrd</tt> struct, although many accessor functions are
available as well.  The value of looking at the struct definitions above is
to understand what information can be represented.  There is one
<tt>NrrdAxis</tt> struct for each axis (or dimension) in the dataset,
and the only necessary piece of information is the <tt>size</tt>;
everything else is optional meta-information.  <tt>spacing</tt>,
<tt>thickness</tt>, <tt>min</tt>, and <tt>max</tt> are all doubles
which follow the convention that if no useful value is known, then the
value is set to <tt>AIR_NAN</tt>, which represents
Not-A-Number. <tt>label</tt> and <tt>units</tt> are standard C char*
strings.  The <tt>center</tt> field takes on values from the 
<tt>nrrdCenter</tt> enum (above).

<p>

In the <tt>Nrrd</tt> struct, the basic information describing the
array are given in <tt>data</tt>, <tt>type</tt>, and <tt>dim</tt>.
<tt>type</tt> takes values from the <tt>nrrdType</tt> enum (above).
Any and all information about the array that is
specific to each axis is in the <tt>axis</tt> array of
<tt>NrrdAxis</tt> structs (note that this is an array of structs, not
an array of pointers to structs).  The rest of the <tt>Nrrd</tt>
struct is for optional meta-information about the array.  Of
particular note is the <tt>kvp</tt> key/value pair array; this becomes
the catch-all for other meta-information that you wish to associated
with an array in a way that will be saved out to a NRRD file, and
recovered upon reading in the file.

<a name="io"><h2>2. Input/Output functions, with error reporting</h2></a>

There are four main I/O functions; two functions for reading, and two
for writing, and you choose depending on whether you giving a
<tt>char*</tt> filename or a <tt>FILE*</tt> file pointer:
<center>
<table border=1 cellpadding=4>
<tr>
  <td>way to specify I/O
  <td>Input
  <td>Output
<tr>
  <td align=right><tt>char*</tt> filename
  <td><tt>nrrdLoad()</tt>
  <td><tt>nrrdSave()</tt>
<tr>
  <td align=right><tt>FILE*</tt> file pointer
  <td><tt>nrrdRead()</tt>
  <td><tt>nrrdWrite()</tt>
</table>
</center>
<tt>nrrdLoad()</tt> and <tt>nrrdSave()</tt> are more commonly used.

<p>

As with most functions in <b>Teem</b> libraries, these functions
return an <tt>int</tt> to signify an error condition or successful
completion.  <b>Teem</b> uses verbose, detailed, textual error messages
in favor of cryptic, integer error codes.  The error messages
accumulate in a seperate library devoted to error handling, called
<b>biff</b>.  Thus, handling errors in <b>Nrrd</b> (or any other
<b>Teem</b> library) involves making <b>biff</b> calls to get the
error messages.  Here is a fairly complete/pedantic example of using
<tt>nrrdLoad</tt> and <tt>nrrdSave</tt> with error handling:

<blockquote><pre>
#include &lt;teem/nrrd.h&gt;

void
demoIO(char *filename) {
  char me[]="demoIO", newname[]="foo.nrrd", *err;
  Nrrd *nin;

  /* create a nrrd; at this point this is just an empty container */
  nin = nrrdNew();

  /* read in the nrrd from file */
  if (nrrdLoad(nin, filename, NULL)) {
    err = biffGetDone(NRRD);
    fprintf(stderr, "%s: trouble reading \"%s\":\n%s", me, filename, err);
    free(err);
    return;
  }

  /* say something about the array */
  printf("%s: \"%s\" is a %d-dimensional nrrd of type %d (%s)\n", 
         me, filename, nin-&gt;dim, nin-&gt;type,
         airEnumStr(nrrdType, nin-&gt;type));
  printf("%s: the array contains %d elements, each %d bytes in size\n",
         me, (int)nrrdElementNumber(nin), (int)nrrdElementSize(nin));

  /* write out the nrrd to a different file */
  if (nrrdSave(newname, nin, NULL)) {
    err = biffGetDone(NRRD);
    fprintf(stderr, "%s: trouble writing \"%s\":\n%s", me, newname, err);
    free(err);
    return;
  }

  /* blow away both the Nrrd struct *and* the memory at nin-&gt;data
     (nrrdNix() frees the struct but not the data,
     nrrdEmpty() frees the data but not the struct) */
  nrrdNuke(nin);

  return;
}
</pre></blockquote>

Things to note here:
<ul>
<li> With <tt>nrrdLoad()</tt> and <tt>nrrdSave()</tt>, a non-zero return
means "there were problems"; a return of zero means "everything is okay".
<li> The <tt>NULL</tt> argument to <tt>nrrdLoad()</tt> and <tt>nrrdSave()</tt>
is a place-holder for a <tt>NrrdIO</tt> struct, which is used whenever 
you want to over-ride the default behavior of the I/O functions.  
Experience has shown that the defaults probably do what you want.
<li> You pass "<tt>NRRD</tt>" to <tt>biffGetDone()</tt> because you know
that the function that just died is in the <b>Nrrd</b> library.
To be good, you do have to free the <tt>char*</tt> that is returned
from biff.
<li> <tt>nrrdType</tt> is a thing called an <tt>airEnum</tt>, which 
facilitates mapping between strings and integral enum values.
<tt>airEnumStr()</tt> maps from the enum value to a string
(<tt>airEnumVal()</tt> goes the other way).
<li> <tt>nrrdElementNumber()</tt> and <tt>nrrdElementSize()</tt> both
return type <tt>size_t</tt>, thus the cast to <tt>int</tt> for printing.
</ul>

This code snippet is available as a stand-alone program <a
href="demoIO.c"><tt>demoIO.c</tt></a>.  When invoked on the <a
href="hi.png"><tt>hi.png</tt></a> file created on the <a
href="otherformat.html">Other Formats</a> page:
<blockquote><pre>
<b>&gt;</b><b>&gt;</b> demoIO hi.png
demoIO: "hi.png" is a 2-dimensional nrrd of type 2 (unsigned char)
demoIO: the array contains 35 elements, each 1 bytes in size

<b>&gt;</b><b>&gt;</b> demoIO foo.nrrd
demoIO: "foo.nrrd" is a 2-dimensional nrrd of type 2 (unsigned char)
demoIO: the array contains 35 elements, each 1 bytes in size

<b>&gt;</b><b>&gt;</b> unu head foo.nrrd
NRRD0001
content: (unsigned char)(???)
type: unsigned char
dimension: 2
sizes: 7 5
encoding: raw

<b>&gt;</b><b>&gt;</b> rm -f foo.nrrd

<b>&gt;</b><b>&gt;</b> demoIO foo.nrrd
demoIO: trouble reading "foo.nrrd":
[nrrd] nrrdLoad: fopen("foo.nrrd","rb") failed: No such file or directory
</pre></blockquote>

<ul>
<li> <tt><a href="../unrrdu/index.html">unu</a> head</tt> is being demonstrated as an easy way to inspect
the header of a NRRD file (much easier than using <tt>more</tt> or
<tt>less</tt>!)
</ul>

<a name="alloc"><h2>3. Reading a NRRD with a different memory allocator</h2></a>

In some cases you want to read a NRRD in, but you want to do the
memory allocation, instead of the nrrd library doing it for you.  This
is supported in nrrd, but you have to read the nrrd in two steps: the
first time reads the nrrd header so that you can figure out how much
memory to allocate, and the second time reads in the data (as well
as re-reading the header).  This function demonstrates this:

<blockquote><pre>
Nrrd *
customLoad(char *filename) {
  char me[]="demoIO", *err;
  NrrdIoState *nio;
  Nrrd *nin;
  void *data;
  
  /* create a new nrrd */
  nin = nrrdNew();
  
  /* tell nrrdLoad to only read the header, not the data */
  nio = nrrdIoStateNew();
  nrrdIoStateSet(nio, nrrdIoStateSkipData, AIR_TRUE);
  
  /* read in the nrrd header from file */
  if (nrrdLoad(nin, filename, nio)) {
    err = biffGetDone(NRRD);
    fprintf(stderr, "%s: trouble reading \"%s\" header:\n%s",
            me, filename, err);
    free(err); nio = nrrdIoStateNix(nio);
    return NULL;
  }
  
  /* we're done with the nrrdIoState, this sets it to NULL */
  nio = nrrdIoStateNix(nio);

  /* 1) YOU, the nrrd user, look at things like nin-&gt;dim, nin-&gt;type
     nin-&gt;axis[0].size, nin-&gt;axis[1].size, etc in order allocate the data
     for the nrrd.  There are two convenience functions you should use:
     1) nrrdElementNumber(nin) returns the total number of sample values.
     2) nrrdElementSize(nin) returns the number of bytes in each value.
     Make sure that the data is allocated as one single contiguous address
     range, or else nrrd will not operate correctly on the values. */

  /* 2) YOU now set nin-&gt;data to the beginning of your allocated memory */
  nin-&gt;data = YOUR POINTER HERE;
  
  /* 3) Now load the nrrd again, this time actually reading the data.
     The existing nin-&gt;data memory will be used, because nrrdRead
     (called by nrrdLoad) remembers the address and size of incoming
     allocated data, and eventually it will get used, instead of
     nrrd allocating new memory */
  if (nrrdLoad(nin, filename, NULL)) {
    err = biffGetDone(NRRD);
    fprintf(stderr, "%s: trouble reading \"%s\" data:\n%s",
	    me, filename, err);
    free(err);
    return NULL;
  }

  /* return the nrrd.  When your program is done with the nrrd, the right
     way to get rid of it is probably nrrdNix(): this will destroy the
     Nrrd struct and its storage for meta information, but not the underlying
     nrrd-&gt;data.  nrrdNuke(), on the other hand, will free(nin-&gt;data) */
  return nin;
}
</pre></blockquote>

<a name="data"><h2>4. Getting data into and out of nrrds</h2></a>

Suppose that you have a 128-by-128-by-64 3-D array of <tt>double</tt>s
in memory (pointed to by the variable <tt>val</tt>) that you've
generated as part of some computation, and you want to save this array
out to disk in NRRD format.  Forgetting about error checking, this can
be done in four steps:

<blockquote><pre>
Nrrd *nval;
...
nval = nrrdNew();
nrrdWrap(nval, val, nrrdTypeDouble, 3, 128, 128, 64);
nrrdSave("val.nrrd", nval, NULL);
nrrdNix(nval);
</pre></blockquote>

<tt>nrrdWrap()</tt> uses var-args based on the dimension of the array
(3 in the example above) to know how many integer axis size arguments
to expect.  Calling <tt>nrrdNix()</tt> and not <tt>nrrdNuke()</tt> here
is important: we just want to get rid of the struct around the data,
not the data itself.  One thing to keep in mind is that currently,
<b>nrrd</b> has no notion of data ownership.  The <tt>Nrrd</tt> struct
doesn't know anything about whether or not its okay to delete the
array inside when you called <tt>nrrdNuke()</tt> on it.

<p>

The raster ordering of the data determines whether the last arguments
to <tt>nrrdWrap()</tt> should be (128, 128, 64) or (64, 128, 128).
In <b>nrrd</b>, axis-related things are <b>always</b> listed from
<b>fast</b> to <b>slow</b>.  See the <a href="intro.html">Introduction</a>
for an explanation of fast and slow axes.

<p>

Adding error checking is not too hard:

<blockquote><pre>
Nrrd *nval;
char *err;
...
nval = nrrdNew();
if (nrrdWrap(nval, val, nrrdTypeDouble, 3, 128, 128, 64)
    || nrrdSave("val.nrrd", nval, NULL)) {
  err = biffGetDone(NRRD); 
  ...
}
nrrdNix(nval);
</pre></blockquote>

The idiom here is that a long sequence of <b>nrrd</b> calls, all
of which return <tt>int</tt>s, can be chained together as a single
boolean expression, so that as soon as one fails, none of the following
ones will be called.

<p>

If you want <b>nrrd</b> to allocate the memory for you, then
you would use <tt>nrrdAlloc()</tt> and <tt>nrrdNuke()</tt>:

<blockquote><pre>
Nrrd *nval;
double *val;
int sx=128, sy=128, sz=64;
...
nval = nrrdNew();
nrrdAlloc(nval, nrrdTypeDouble, 3, sx, sy, sz);
val = (double*)nval-&gt;data;
val[10 + sx*(20 + sy*30)] = 42;     /* val[x=10,y=20,z=30] = 42 */
...
nrrdNuke(nval);
</pre></blockquote>

Calling <tt>nrrdNuke()</tt> is appropriate here because <b>nrrd</b>
allocated the memory for you in <tt>nrrdAlloc()</tt>, and
<tt>nrrdNuke()</tt> will free that memory.  The "<tt>val[10 + sx*(20 +
sy*30)] = 42</tt>" is just one example of how to access values in a
multi-dimensional array, but many others are possible and preferable.
<b>Nrrd</b> is so agnostic about multi-dimensional data access that it
provides no direct facilities for setting and getting values based on
a coordinate vector; there are only minimal facilities for
setting/getting values based on a one-dimensional index.

<p>

Remember this pairing: <tt>nrrdWrap()</tt> with <tt>nrrdNix()</tt>,
and <tt>nrrdAlloc()</tt> with <tt>nrrdNuke()</tt>.

<a name="peraxis"><h2>5. Setting/Getting per-axis information</h2></a>

The ability to store meta-information descriptive of each axis of a
multi-dimensional array is one of the main differences between "raw"
data, and the "nearly raw" data that <b>nrrd</b> supports.  The API
has a few functions, all starting with <tt>nrrdAxisInfo...</tt>, which
are used to set and get axis information, but there are only two which
are commonly used: <tt>nrrdAxisInfoGet()</tt> and
<tt>nrrdAxisInfoSet()</tt>.  The way to communicate <b>which</b> field
of the <tt>NrrdAxis</tt> struct that you wish to set/get is via
a C enum, which includes these self-descriptive values:
<ul>
<li> <tt>nrrdAxisInfoSize</tt>
<li> <tt>nrrdAxisInfoSpacing</tt>
<li> <tt>nrrdAxisInfoThickness</tt>
<li> <tt>nrrdAxisInfoMin</tt>
<li> <tt>nrrdAxisInfoMax</tt>
<li> <tt>nrrdAxisInfoSpaceDirection</tt>
<li> <tt>nrrdAxisInfoCenter</tt>
<li> <tt>nrrdAxisInfoKind</tt>
<li> <tt>nrrdAxisInfoLabel</tt>
<li> <tt>nrrdAxisInfoUnits</tt>
</ul>

Note the one-to-one correspondence between these enum values and the
individual fields in the <tt>NrrdAxis</tt> struct defined above.  For
example, if you want to set labels ("x", "y", "z") for each of the
three axes in <tt>nval</tt>:

<blockquote><pre>
nrrdAxisInfoSet(nval, nrrdAxisInfoLabel, "x", "y", "z");
</pre></blockquote>

Because <b>nrrd</b> has the mentality that "everything is a scalar",
you'll need a 4-D array to represent a volume in which each voxel
has multiple values associated with it, such as with a 3-D vector
field.  The "kind" per-axis information is how <b>nrrd</b> provides
guidance on representing this situation:

<blockquote><pre>
nrrdAxisInfoSet(nvec, nrrdAxisInfoKind,
                nrrdKind3Vector, nrrdKindSpace, nrrdKindSpace, nrrdKindSpace);
nrrdAxisInfoSet(nvec, nrrdAxisInfoLabel, "Vx;Vy;Vz", "x", "y", "z");
</pre></blockquote>

Recovering these values from a given nrrd can be done this way
if you know exactly what the dimension of the nrrd is:

<blockquote><pre>
char *lab0, *lab1, *lab2, *lab3;
int *kind0, *kind1, *kind2, *kind3;
...
nrrdAxisInfoGet(nvec, nrrdAxisInfoLabel, &amp;lab0, &amp;lab1, &amp;lab2, &amp;lab3);
nrrdAxisInfoGet(nvec, nrrdAxisInfoKind, &amp;kind0, &amp;kind1, &amp;kind2, &amp;kind3);
printf("labels were: \"%s\", \"%s\", \"%s\", \"%s\"\n",
       lab0, lab1, lab2, lab3);
printf("kinds were: %s (%d), %s (%d), %s (%d), %s (%d)\n",
       airEnumStr(nrrdKind, kind0), kind0,
       airEnumStr(nrrdKind, kind1), kind1,
       airEnumStr(nrrdKind, kind2), kind2,
       airEnumStr(nrrdKind, kind3), kind3);
</pre></blockquote>

It may be easier to use the dimensionally general version of the
function:

<blockquote><pre>
char *lab[NRRD_DIM_MAX];
int kind[NRRD_DIM_MAX];
int di;
...
nrrdAxisInfoGet_nva(nvec, nrrdAxisInfoLabel, lab);
nrrdAxisInfoGet_nva(nvec, nrrdAxisInfoKind, kind);
for (di=0; di<nvec->dim; di++) {
  printf("axis %d: label = \"%s\", kind = %s (%d)\n",
         di, lab[di], airEnumStr(nrrdKind, kind[di]), kind[di]);
}
</pre></blockquote>
<ul>

<li> <tt>NRRD_DIM_MAX</tt> is a compile-time limit on the dimension
of the nrrd that can be handled.  This is currently set to 16.
Having a compile-time max <b>greatly</b> simplifies many things that would
otherwise have to be handled dynamically.

<li> Note that the function name ends with "<tt>_nva</tt>" to signify
"no variable arguments"; all var-arg <b>nrrd</b> functions have an
analagous non-var-arg version that ends with <tt>_nva</tt>.  

<li> Rule of thumb for string allocation and the <b>nrrd</b> API:
<b>every string is strdup()ed</b>.  That means that internally,
<tt>nrrdAxisInfoSet()</tt> copies the strings passed to it (so it is
not reliant on the long-term existance of the strings passed to it),
and <tt>nrrdAxisInfoGet()</tt> gives you copies of the strings stored
inside (so that you can free these strings without worrying about
invalidating the internal pointers,
e.g. <tt>nval-&gt;axis[0].label</tt>).

</ul>

<!--
<p>

Using <tt>nrrdAxisInfoGet()</tt> is always harmless, and
<tt>nrrdAxisInfoSet()</tt> is usually harmless, but you can really
confuse things by calling <tt>nrrdAxisInfoSet(nrrd, nrrdAxisInfoSize,...)</tt>
and giving an inconsistent set of axis sizes.  Currently, not even a
warning message is printed in this case!
-->

<p>

Here is a more complete example of setting axis labels, centerings, and
spacings:

<blockquote><pre>
nrrdAxisInfoSet(nvec, nrrdAxisInfoLabel, "Vx;Vy;Vz", "x", "y", "z");
nrrdAxisInfoSet(nvec, nrrdAxisInfoKind,
                nrrdKind3Vector, nrrdKindSpace, nrrdKindSpace, nrrdKindSpace);
nrrdAxisInfoSet(nvec, nrrdAxisInfoCenter,
                nrrdCenterUnknown,
                nrrdCenterNode, nrrdCenterNode, nrrdCenterNode);
nrrdAxisInfoSet(nvec, nrrdAxisInfoSpacing, AIR_NAN, 1.0, 1.0, 2.0);
</pre></blockquote>

<tt>nrrdCenterUnknown</tt> means "I don't know the centering" or
"Centering is moot for this axis".  Using <tt>AIR_NAN</tt> for any
<tt>double</tt>-type per-axis field (spacing, min, or max) similiarly
means "don't know", "don't care".

<a name="keyvalue"><h2>6. Key/Value Pairs</h2></a>

This is the simple but flexible way to store extra fields of
information in a <tt>Nrrd</tt>.  These will be preserved exactly when
saved to, and read from, a NRRD file.  For example, if you want to
save some rendering parameters with a floating point rendered image,
you might save pairs like ("camera", "4, 5, 0"), ("look-at", "0, 0,
0"), ("U range", "-1, 1"), and so forth.  Both the key and the value
are just <tt>char*</tt> strings, but hopefully packing and unpacking
between strings and useful values is probably the least of your
problems.  Here are the calls to add the key/value pairs listed above:

<blockquote><pre>
nrrdKeyValueAdd(nrend, "camera", "4, 5, 0");
nrrdKeyValueAdd(nrend, "look-at", "0, 0, 0");
nrrdKeyValueAdd(nrend, "U range", "-1, 1");
</pre></blockquote>

To retrieve values:
<blockquote><pre>
char *cam, *at;
...
cam = nrrdKeyValueGet(nrend, "camera");
at = nrrdKeyValueGet(nrend, "look-at");
printf("camera = %s, look-at = %s\n", cam, at);
free(cam); free(at);
cam = NULL; at = NULL;
</pre></blockquote>

You can also iterate over all key/value pairs:

<blockquote><pre>
int ki, nk;
char *key, *val;
...
nk = nrrdKeyValueSize(nrend);
for (ki=0; ki&lt;nk; ki++) {
  nrrdKeyValueIndex(nrend, &amp;key, &amp;val, ki);
  printf("%s = %s\n", key, val);
  free(key); free(val);
  key = NULL; val = NULL;
}
</pre></blockquote>

<p>

Following the "all strings are strdup()ed" rule of thumb for strings in NRRD,
the return from <tt>nrrdKeyValueGet()</tt> and 
<tt>nrrdKeyValueIndex</tt> should be <tt>free()</tt>d.
Individual key/value pairs are erased with <tt>nrrdKeyValueErase()</tt>,
all pairs are erased with <tt>nrrdKeyValueClear()</tt>.

<a name="space"><h2>7. Space and orientation</h2></a>

Starting with version 4 of the NRRD format (with magic "<tt>NRRD0004</tt>"),
the <tt>Nrrd</tt> struct can describe how the array is oriented and 
positioned relative to some surrounding space.  See the <a href="format.html#space">relevant section of the NRRD file format spec</a> to see what
space and orientation information can be represented.  The values of
<tt>nrrd-&gt;space</tt> come from an enum (in <tt>nrrdEnums.h</tt>):

<blockquote><pre>
/*
******** nrrdSpace* enum
**
** Identifies the space in which which the origin and direction
** vectors have their coordinates measured.  When a direction is named
** here (like "Left" or "Anterior"), that implies a basis vector that
** points in that direction, along which that coordinate becomes *larger*
** (this is the opposite of MetaIO, for example).
**
** All of these spaces have a well-defined expected dimension, as
** determined by nrrdSpaceDimension(), and setting a nrrd to be in
** such a space, by nrrdSpaceSet(), will automatically set nrrd-&gt;spaceDim.
**
** The first six spaces here are PATIENT-ORIENTED spaces, which are
** properly speaking aligned with the patient, and not the scanner
** itself.  But nrrdSpaceScannerXYZ and nrrdSpaceScannerXYZTime are
** DEVICE-ORIENTED spaces, irrespective of the patient, used in a
** previous version of the DICOM standard.  When the two spaces are
** lined up with normal patient orientation in the scanner,
** nrrdSpaceScannerXYZ is the same as nrrdSpaceLeftPosteriorSuperior.
** To quote Part 3 (Information Object Definitions) of the DICOM spec
** (page 275): "If a patient lies parallel to the ground, face-up on
** the table, with his feet-to-head direction same as the
** front-to-back direction of the imaging equipment, the direction of
** the axes of this patient based coordinate system and the equipment
** based coordinate system in previous versions of this Standard will
** coincide."
*/
enum {
  nrrdSpaceUnknown,
  nrrdSpaceRightAnteriorSuperior,     /*  1: NIFTI-1 (right-handed) */
  nrrdSpaceLeftAnteriorSuperior,      /*  2: standard Analyze (left-handed) */
  nrrdSpaceLeftPosteriorSuperior,     /*  3: DICOM 3.0 (right-handed) */
  nrrdSpaceRightAnteriorSuperiorTime, /*  4: */
  nrrdSpaceLeftAnteriorSuperiorTime,  /*  5: */
  nrrdSpaceLeftPosteriorSuperiorTime, /*  6: */
  nrrdSpaceScannerXYZ,                /*  7: ACR/NEMA 2.0 (pre-DICOM 3.0) */
  nrrdSpaceScannerXYZTime,            /*  8: */
  nrrdSpace3DRightHanded,             /*  9: */
  nrrdSpace3DLeftHanded,              /* 10: */
  nrrdSpace3DRightHandedTime,         /* 11: */
  nrrdSpace3DLeftHandedTime,          /* 12: */
  nrrdSpaceLast
};
</pre></blockquote>

There are some
API functions which facilitate setting and getting this information.

<ul>
<li> <tt>int nrrdSpaceDimension(int space)</tt><br> returns the dimension 
associated with the given space (from the <tt>nrrdSpace</tt> enum), or 0 if
the space value is unrecognized.
<li> <tt>int nrrdSpaceSet(Nrrd *nrrd, int space)</tt><br> set the space.
<li> <tt>int nrrdSpaceDimensionSet(Nrrd *nrrd, int spaceDim)</tt><br>
set the space dimension, for when the space used is not a recognized and
named space (from the <tt>nrrdSpace</tt> enum).
<li> <tt>int nrrdSpaceKnown(const Nrrd *nrrd)</tt><br>
non-zero return means that
some kind of space or orientiation info is known.  If zero, means that the
only information known is (possibly) the per-axis min, max, spacing.
<li> <tt>void nrrdSpaceGet(const Nrrd *nrrd, int *space, int *spaceDim)</tt><br>
Sets <tt>*space</tt> to the space  and <tt>*spaceDim</tt>  to
the space dimension of the surrounding space.  <tt>*space</tt> will be set to
nrrdSpaceUnknown if the space dimension is known, but no named spaced is
being used.
<li> <tt>void nrrdSpaceOriginGet(const Nrrd *nrrd, double vector[NRRD_SPACE_DIM_MAX])</tt><br> Gets the spaceOrigin from the nrrd (vector[0] through
vector[spaceDim-1] are set).
<li> <tt>int nrrdOriginCalculate3D(const Nrrd *nrrd, int ax0, int ax1, int ax2, int defaultCenter, double origin[3])</tt><br> For those cases where you want 
something like an "origin" even though you don't have space information,
pick the three axes (<tt>ax0</tt>, <tt>ax1</tt>, <tt>ax2</tt>)
that you think represent the spatial
axes of the volume, and pick a default centering
(<tt>nrrdCenterNode</tt> or <tt>nrrdCenterCell</tt>) and this will try
to figure out an origin from the per-axis min, max, and spacing.  Return values are from the <tt>nrrdOriginStatus</tt> enum:
<blockquote><pre>
/*
******** nrrdOriginStatus* enum
**
** how origin information was or was not computed by nrrdOriginCalculate
*/
enum {
  nrrdOriginStatusUnknown,        /* 0: nobody knows, or invalid parms */
  nrrdOriginStatusDirection,      /* 1: chosen axes have spaceDirections */
  nrrdOriginStatusNoMin,          /* 2: axis-&gt;min doesn't exist */
  nrrdOriginStatusNoMaxOrSpacing, /* 3: axis-&gt;max or -&gt;spacing doesn't exist */
  nrrdOriginStatusOkay,           /* 4: all is well */
  nrrdOriginStatusLast
};
</pre></blockquote>
<li> <tt>int nrrdSpacingCalculate(const Nrrd *nrrd, int ax, double *spacing, double vector[NRRD_SPACE_DIM_MAX])</tt>: determine spacing information for
the given axis.  This is useful for nrrd with and without space information,
since the information can come either from the per-axis spacing or the
per-axis space direction.  Return value indicates status of information:
<blockquote><pre>
/*
******** nrrdSpacingStatus* enum
**
** a way of describing how spacing information is known or not known for a 
** given axis, as determined by nrrdSpacingCalculate
*/
enum {
  nrrdSpacingStatusUnknown,           /* 0: nobody knows,
                                         or invalid axis choice */
  nrrdSpacingStatusNone,              /* 1: neither axis-&gt;spacing nor
                                         axis-&gt;spaceDirection is set */
  nrrdSpacingStatusScalarNoSpace,     /* 2: axis-&gt;spacing set,
                                         w/out space info */
  nrrdSpacingStatusScalarWithSpace,   /* 3: axis-&gt;spacing set, but there *is*
                                         space info, which means the spacing
                                         does *not* live in the surrounding
                                         space */
  nrrdSpacingStatusDirection,         /* 4: axis-&gt;spaceDirection set, and 
                                         measured according to surrounding
                                         space */
  nrrdSpacingStatusLast
};
</pre></blockquote>
</ul>

<a name="overview"><h2>8. Overview of rest of API</h2></a>

The following aims to give a brief description of the important
<b>nrrd</b> library calls.  See <tt>teem/src/nrrd/nrrd.h</tt> for
a complete list.

<p>

Programmers interested in seeing example code that uses the
<b>Nrrd</b> API are encouraged to look at the <b>Unrrdu</b>
commands that call into <b>Nrrd</b> functions.  For example,
<tt>teem/src/unrrdu/slice.c</tt> demonstrates how to call
<tt>nrrdSlice()</tt>.

<h3>Basic "methods"</h3>

These handle the basic operations for creating and destroying
nrrds and the data inside

<center>
<table border=0 cellpadding=2>
<tr>
<td align=right><tt>nrrdNew</tt>
<td><b>-</b>
<td align=left>Create an emtpy nrrd (a container)
<tr>
<td align=right><tt>nrrdNix</tt>
<td><b>-</b>
<td align=left>Delete the nrrd struct, but not the data
<tr>
<td align=right><tt>nrrdEmpty</tt>
<td><b>-</b>
<td align=left>Free the data, keep the struct
<tr>
<td align=right><tt>nrrdNuke</tt>
<td><b>-</b>
<td align=left>Free both the data and the struct
<tr>
<td align=right><tt>nrrdCopy</tt>
<td><b>-</b>
<td align=left>Replicate a struct and the data inside
<tr>
<td align=right><tt>nrrdAlloc</tt>
<td><b>-</b>
<td align=left>allocate the data segment of a nrrd
<tr>
<td align=right><tt>nrrdMaybeAlloc</tt>
<td><b>-</b>
<td align=left>allocate the data segment if the requested size<br>
is different than the current one
</table>
</center>

<h3>Manipulation of per-axis meta-information</h3>

<center>
<table border=0 cellpadding=2>
<tr>
<td align=right><tt>nrrdAxisInfoCopy</tt>
<td><b>-</b>
<td align=left>Copy per-axis info from one nrrd to another
<tr>
<td align=right><tt>nrrdAxisInfoSet{_nva}</tt>
<td><b>-</b>
<td align=left>Set one field of axis, for all axes
<tr>
<td align=right><tt>nrrdAxisInfoGet{_nva}</tt>
<td><b>-</b>
<td align=left>Get one field of axis, for all axes
<tr>
<td align=right><tt>nrrdAxisInfoPos</tt>
<td><b>-</b>
<td align=left>Map from axis "index space" to "world space"
<tr>
<td align=right><tt>nrrdAxisInfoIdx</tt>
<td><b>-</b>
<td align=left>Map from axis "world space" to "index space"
<tr>
<td align=right><tt>nrrdAxisInfoSpacingSet</tt>
<td><b>-</b>
<td align=left>Set spacing, based on current min/max
<tr>
<td align=right><tt>nrrdAxisInfoMinMaxSet</tt>
<td><b>-</b>
<td align=left>Set min and max, based on current spacing
</table>
</center>

<h3>Utility functions</h3>

<tt>nrrdSanity()</tt> should be called on a new <b>Teem</b> build
to make sure things are all okay.  There is in fact a <b>Teem</b>
stand-alone binary called <tt>nrrdSanity</tt> which is really
just a wrapper around <tt>nrrdSanity()</tt>.

<center>
<table>
<tr>
<td align=right><tt>nrrdSanity</tt>
<td><b>-</b>
<td align=left>checks that all compile-time assumptions are true
<tr>
<td align=right><tt>nrrdContentSet</tt>
<td><b>-</b>
<td align=left>printf-style setting of the nrrd-&gt;content field
<tr>
<td align=right><tt>nrrdCheck</tt>
<td><b>-</b>
<td align=left>make sure a given nrrd's fields are valid and consistent
<tr>
<td align=right><tt>nrrdElementNumber</tt>
<td><b>-</b>
<td align=left>number of samples in a nrrd
<tr>
<td align=right><tt>nrrdElementSize</tt>
<td><b>-</b>
<td align=left>number of bytes in each sample
</table>
</center>

<h3>Comments in nrrd</h3>

Comments used to be the only way to extend the nrrd header with
other kinds of meta-information, but this is strongly discouraged
now that (as of version 1.6.0) we have key/value pairs.

<center>
<table>
<tr>
<td align=right><tt>nrrdCommentAdd</tt>
<td><b>-</b>
<td align=left>add a comment to a nrrd
<tr>
<td align=right><tt>nrrdCommentClear</tt>
<td><b>-</b>
<td align=left>clear all comments in a nrrd
<tr>
<td align=right><tt>nrrdCommentCopy</tt>
<td><b>-</b>
<td align=left>copy all comments from one nrrd to another
</table>
</center>

<h3>Key/value pairs</h3>

Described above.

<center>
<table>
<tr>
<td align=right><tt>nrrdKeyValueAdd</tt>
<td><b>-</b>
<td align=left>add a key/value pair to a nrrd
<tr>
<td align=right><tt>nrrdKeyValueGet</tt>
<td><b>-</b>
<td align=left>look up a value for a given key
<tr>
<td align=right><tt>nrrdKeyValueErase</tt>
<td><b>-</b>
<td align=left>erase a key/value pair, given the key
<tr>
<td align=right><tt>nrrdKeyValueClear</tt>
<td><b>-</b>
<td align=left>clear all key/value pairs in a nrrd
<tr>
<td align=right><tt>nrrdKeyValueSize</tt>
<td><b>-</b>
<td align=left>number of key/value pairs in a nrrd
<tr>
<td align=right><tt>nrrdKeyValueIndex</tt>
<td><b>-</b>
<td align=left>lookup a key/value pair, indexed by integer
</table>
</center>

<h3>Endianness (byte ordering)</h3>

<b>Nrrd</b> is designed so that you don't have to worry about
endianness.  Whenever the byte ordering of an array matters
(when the element size is larger than one byte), and the array
is written out with an encoding which exposes endianness (anything
besides ASCII), then the endianness is explicitly recorded,
in the header.  On read, the endianness if flipped automatically
(by <tt>nrrdRead()</tt>) if it is deemed necessary.  If, for some
twisted reason, you want to change endianness again, this function
allows you to do so.

<center>
<table>
<tr>
<td align=right><tt>nrrdSwapEndian</tt>
<td><b>-</b>
<td align=left>reverses the byte-ordering of the data in memory
</table>
</center>

<h3>Getting/Setting values (crude!)</h3>

These functions provide a primitive means of setting/getting values
in an array of type known only at run-time.  Here's an example of
their use, to add <tt>incr</tt> to all the values in a nrrd:

<blockquote><pre>
void
demoIncr(Nrrd *nrrd, double incr) {
  double (*lup)(const void *, size_t I);
  double (*ins)(const void *, size_t I, double v);
  double val;
  size_t I, N;
  
  lup = nrrdDLookup[nrrd-&gt;type];
  ins = nrrdDInsert[nrrd-&gt;type];
  N = nrrdElementNumber(nrrd);
  for (I=0; I&lt;N; I++) {
    val = lup(nrrd-&gt;data, I);
    val += incr;
    ins(nrrd-&gt;data, I, val);
  }
  return;
}
</pre></blockquote>

<center>
<table>
<tr>
<td align=right><tt>nrrd{I,F,D}Load[]</tt>
<td><b>-</b>
<td align=left>dereference a pointer (of indexed type), and cast to
<tt>int</tt>, <tt>float</tt>, or <tt>double</tt>
<tr>
<td align=right><tt>nrrd{I,F,D}Store[]</tt>
<td><b>-</b>
<td align=left>save a given <tt>int</tt>, <tt>float</tt>, or <tt>double</tt>
to the given pointer (which is of indexed type)
<tr>
<td align=right><tt>nrrd{I,F,D}Lookup[]</tt>
<td><b>-</b>
<td align=left>lookup a value in a given array (of indexed type), and 
cast to <tt>int</tt>, <tt>float</tt>, or <tt>double</tt>
<tr>
<td align=right><tt>nrrd{I,F,D}Insert[]</tt>
<td><b>-</b>
<td align=left>insert the given <tt>int</tt>, <tt>float</tt>, or
<tt>double</tt> of a particular element of a given array
(which is of indexed type)
</table>
</center>

<h3>Input from, Output to files</h3>

Described above.

<center>
<table>
<tr>
<td align=right><tt>nrrdLoad</tt>
<td><b>-</b>
<td align=left>load a nrrd from a given <tt>char*</tt> filename
<tr>
<td align=right><tt>nrrdRead</tt>
<td><b>-</b>
<td align=left>read a nrrd from a given <tt>FILE*</tt> file pointer
<tr>
<td align=right><tt>nrrdSave</tt>
<td><b>-</b>
<td align=left>save a nrrd to a given <tt>char*</tt> filename
<tr>
<td align=right><tt>nrrdWrite</tt>
<td><b>-</b>
<td align=left>write a nrrd to a given <tt>FILE*</tt> file pointer
</table>
</center>

<h3>Representing ranges of values</h3>

The <tt>NrrdRange</tt> is a very simple struct who's only job
is to represent (you guessed!) a range of scalar values, either as
a description of what was seen in a given nrrd, or as input to
a function like <tt>nrrdQuantize</tt> which uses a value range as
part of its operation.  The introduction of the <tt>NrrdRange</tt> was
the chosen means of making <b>nrrd</b> const-correct.

<center>
<table>
<tr>
<td align=right><tt>nrrdRangeNew</tt>
<td><b>-</b>
<td align=left>create a new <tt>NrrdRange</tt> based on the given
min and max
<tr>
<td align=right><tt>nrrdRangeNix</tt>
<td><b>-</b>
<td align=left>delete a <tt>NrrdRange</tt>
<tr>
<td align=right><tt>nrrdRangeCopy</tt>
<td><b>-</b>
<td align=left>allocate and produce a replicate of the given nrrd
<tr>
<td align=right><tt>nrrdRangeReset</tt>
<td><b>-</b>
<td align=left>reset a <tt>NrrdRange</tt> to base state
<tr>
<td align=right><tt>nrrdRangeSet</tt>
<td><b>-</b>
<td align=left>Go through the given nrrd and find its min and max.
<tr>
<td align=right><tt>nrrdRangeSafeSet</tt>
<td><b>-</b>
<td align=left>Like nrrdRangeSet, but only over-write non-NaN values
in the given <tt>NrrdRange</tt>
<tr>
<td align=right><tt>nrrdRangeNewSet</tt>
<td><b>-</b>
<td align=left>combines <tt>nrrdRangeNew()</tt> and <tt>nrrdRangeSet</tt>
</table>
</center>

<h3>Simple transforms and warpings of values</h3>

<center>
<table>
<tr>
<td align=right><tt>nrrdConvert</tt>
<td><b>-</b>
<td align=left>make a new nrrd which is the result of doing a
per-value cast on the old values
<tr>
<td align=right><tt>nrrdQuantize</tt>
<td><b>-</b>
<td align=left>reduce the values in a nrrd down to unsigned 8, 16, or 32 bits.a
<tr>
<td align=right><tt>nrrdUnquantize</tt>
<td><b>-</b>
<td align=left>try to recover original floating-point values from
a quantized nrrd based on the <tt>oldMin</tt> and <tt>oldMax</tt> fields.
<tr>
<td align=right><tt>nrrdHistoEq</tt>
<td><b>-</b>
<td align=left>perform histogram equalization on the values in a nrrd
</table>
</center>

<h3>Functional mapping of values</h3>

In all of the following, the values produced at the output of
the mapping can either be scalar (output is same dimension as
in input) or multi-scalar, e.g. color (output is one greater
dimension than input).

<center>
<table>
<tr>
<td align=right><tt>nrrdApply1DLut</tt>
<td><b>-</b>
<td align=left>send values in a nrrd through a univariate lookup-table
<tr>
<td align=right><tt>nrrdApply2DLut</tt>
<td><b>-</b>
<td align=left>send values in a nrrd through a bivariate lookup-table
<tr>
<td align=right><tt>nrrdApply1DRegMap</tt>
<td><b>-</b>
<td align=left>send values in a nrrd through a map of linear ramps
with uniformly spaced control points
<tr>
<td align=right><tt>nrrdApply1DIrregMap</tt>
<td><b>-</b>
<td align=left>send values in a nrrd through a map of linear ramps
with irregularly located control points
<tr>
<td align=right><tt>nrrdApply1DSubstitution</tt>
<td><b>-</b>
<td align=left>send values through a substitution table
</table>
</center>

<h3>Subset/Superset operations</h3>

<center>
<table>
<tr>
<td align=right><tt>nrrdSlice</tt>
<td><b>-</b>
<td align=left>slice an array along some axis at some position
(decreases dimension by one)
<tr>
<td align=right><tt>nrrdSplice</tt>
<td><b>-</b>
<td align=left>put a given slice into a gived nrrd (logical opposite of
<tt>nrrdSlice</tt>)
<tr>
<td align=right><tt>nrrdCrop</tt>
<td><b>-</b>
<td align=left>extract a sub-array of the same dimension
<tr>
<td align=right><tt>nrrdPad</tt>
<td><b>-</b>
<td align=left>pad an array out to be bigger (same dimension)
<tr>
<td align=right><tt>nrrdInset</tt>
<td><b>-</b>
<td align=left>drop some sub-volume into a larger one (logical 
opposite of <tt>nrrdCrop</tt>)
</table>
</center>

<h3>Axis-based value re-ordering</h3>

Unlike the functions about axis meta-information (starting with
<tt>nrrdAxisInfo...</tt>), the functions relating to transforms
on the scan-line ordering of the samples themselves all start
with <tt>nrrdAxes...</tt>.  This may not have been the wisest choice,
but its here now.

<center>
<table>
<tr>
<td align=right><tt>nrrdAxesPermute</tt>
<td><b>-</b>
<td align=left>re-order axes in the scan-line ordering of samples
<tr>
<td align=right><tt>nrrdAxesSwap</tt>
<td><b>-</b>
<td align=left>re-order two specific axes
(special case of <tt>nrrdAxesPermute</tt>)
<tr>
<td align=right><tt>nrrdShuffle</tt>
<td><b>-</b>
<td align=left>re-order slices along some axis
<tr>
<td align=right><tt>nrrdFlip</tt>
<td><b>-</b>
<td align=left>changes ordering of slices along some axis
(special case of <tt>nrrdShuffle</tt>)
<tr>
<td align=right><tt>nrrdJoin</tt>
<td><b>-</b>
<td align=left>join multiple input nrrds along some existing
axis or a new one
<tr>
<td align=right><tt>nrrdReshape</tt>
<td><b>-</b>
<td align=left>(like Matlab's command) impose some new
raster dimensions on an existing array
<tr>
<td align=right><tt>nrrdAxesInsert</tt>
<td><b>-</b>
<td align=left>insert a new stub (size=1) axis amongst some existing ones
<tr>
<td align=right><tt>nrrdAxesDelete</tt>
<td><b>-</b>
<td align=left>remove a stub axis from a nrrd
<tr>
<td align=right><tt>nrrdAxesSplit</tt>
<td><b>-</b>
<td align=left>split one axis into two adjacent axes (a fast and a slow)
<tr>
<td align=right><tt>nrrdAxesMerge</tt>
<td><b>-</b>
<td align=left>Join two adjacent axes into a single axis
<tr>
<td align=right><tt>nrrdTile2D</tt>
<td><b>-</b>
<td align=left>Tile the slices along one axis into two other axes
(makes a mosaic image)
<tr>
<td align=right><tt>nrrdUntile2D</tt>
<td><b>-</b>
<td align=left>Undoes the action of <tt>nrrdTile2D</tt>
</table>
</center>

<h3>"Measuring" an array</h3>

This is one of the more powerful function calls in <b>nrrd</b>: it
allows you to do axis-aligned maximum intensity projections, find the
L2-norm of each of a volume of vectors, find the median/mean/mode
value of each scanline of a multi-dimensional scatterplot.

<center>
<table>
<tr>
<td align=right><tt>nrrdProject</tt>
<td><b>-</b>
<td align=left>reduce all samples along scanlines (along the given axis)
to a single scalar, according to the given measure.
</table>
</center>

<h3>All things histogram-related</h3>

Because <b>nrrd</b> grew out of ideas on array representation that I
had when writing my <a href="http://www.cs.utah.edu/~gk/MS">Master's
thesis</a>, histograms have always been a key part.

<center>
<table>
<tr>
<td align=right><tt>nrrdHisto</tt>
<td><b>-</b>
<td align=left>generate a histogram of the values in a nrrd
<tr>
<td align=right><tt>nrrdHistoDraw</tt>
<td><b>-</b>
<td align=left>draws a uni-variate histogram in a helpful way.
<tr>
<td align=right><tt>nrrdHistoAxis</tt>
<td><b>-</b>
<td align=left>replace every scanline with its histogram
(takes a while to wrap head around this)
<tr>
<td align=right><tt>nrrdHistoJoint</tt>
<td><b>-</b>
<td align=left>create multi-dimensional joint histogram of a 
list of nrrds.
</table>
</center>

<h3>Arithmetic operations on one or more nrrds</h3>

<center>
<table>
<tr>
<td align=right><tt>nrrdArithGamma</tt>
<td><b>-</b>
<td align=left>"gamma correct" all values in a nrrd
<tr>
<td align=right><tt>nrrdArithUnaryOp</tt>
<td><b>-</b>
<td align=left>Send all values in a nrrd through some unary
function, e.g. sin(), log(), abs(), etc.
<tr>
<td align=right><tt>nrrdArithBinaryOp</tt>
<td><b>-</b>
<td align=left>do some binary function (takes two arguments) on
two nrrds, or on a nrrd and a constant
<tr>
<td align=right><tt>nrrdArithTernaryOp</tt>
<td><b>-</b>
<td align=left>so some ternary function (takes three arguments) on
nrrds and constants (any possibility barring three constants)
</table>
</center>

<h3>Filtering and Resampling</h3>

The median filtering is cheap and slow.  The spatial resampling, on
the other hand, is a ridiculously complex and multi-purpose function,
but with an aim towards fast computation.  It allows cropping and
padding as part of resampling, using different kernels on different
axes, resampling some axes while leaving others untouched, drawing
from the very large vocabulary of kernels that <b>nrrd</b> is 
compiled with.  See <tt>nrrd.h</tt> and <tt>resampleNrrd.c</tt>
for details, and look at <tt>teem/src/unrrdu/resample.c</tt> for
an example of a simplified interface to the resampler.

<center>
<table>
<tr>
<td align=right><tt>nrrdCheapMedian</tt>
<td><b>-</b>
<td align=left>perform simple histogram-based median filtering
in 1-D, 2-D or 3-D
<tr>
<td align=right><tt>nrrdSpatialResample</tt>
<td><b>-</b>
<td align=left>perform filtered up-sampling or down-sampling
with arbitrary (seperable) kernels
<tr>
<td align=right><tt>nrrdResampleExecute</tt>
<td><b>-</b>
<td align=left>re-implementation of <tt>nrrdSpatialResample</tt>
to allow fast resampling of multiple images
</table>
</center>

<h3>Connected components</h3>

These are pretty slow and stupid for the time being.  They will
be optimized later, but the API should stay put.

<center>
<table>
<tr>
<td align=right><tt>nrrdCCFind</tt>
<td><b>-</b>
<td align=left>find connected components in 1-D, 2-D or 3-D
<tr>
<td align=right><tt>nrrdCCMerge</tt>
<td><b>-</b>
<td align=left>merge some components into others, based on
a variety of criteria
<tr>
<td align=right><tt>nrrdCCSettle</tt>
<td><b>-</b>
<td align=left>assign set of lowest-valued possible component IDs
</table>
</center>

<!--
Currently, the <b>nrrd</b> library, as with all the <b>Teem</b>
libraries, is implemented completely in C.  

There are various aspects
of <b>nrrd</b> that smack of C++ templates, and some that cry out for
templates, but these are the exceptions.  I program in C because its a
simple little language, and I know what I'm doing.  Plus, sticking to
C keeps debugging easy, and it has made porting a snap.  Other people
who have used <b>nrrd</b> in their C++ frameworks have found it very
easy to put their own C++ wrappers around the <tt>Nrrd</tt> C struct:
the contructor calls <tt>nrrdNew()</tt>, the destructor calls
<tt>nrrdNuke</tt>, the "slice" method calls <tt>nrrdSlice()</tt>, the
"convert" method calls <tt>nrrdConvert</tt>, and so on.

-->


<p>
<a href="http://validator.w3.org/check/referer">&nbsp;</a>
</body>
</html>
